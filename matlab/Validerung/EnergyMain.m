function [] = EnergyMain( setName )
% [] = ENERGYMAIN( SETNAME )
% ═════════════════════════════════════════════════════════════════════════
% Performs an analysis of simualtion data compared to measurement data, in
% order to provide the key values for model validation.
% ─────────────────────────────────────────────────────────────────────────
% Author:  sizuest                   Copyright (c) 2012 by Inspire AG, ETHZ
% Date:    15.03.2012                All rights reserved
% Version: 1.1
% ═════════════════════════════════════════════════════════════════════════
%
% For the sucessfull execution, two global variabels are required:
%
%   ─ HOMEDIR:  Root folder of the analysis
%   ─ MEASDIR:  Root folder of the measurements
%
% The variable SETNAME referes to the folder in HOMEDIR name with the 
% following structure:
%
%   ─ SETNAME
%       ├─ energy
%       │   ├─ plots [dir]
%       │   └─ config.m
%       └─ simdata
%           └─ simulation_output.dat
%
% Configuration of the analysis is done in the file "config.m". This file
% has to provide the following variables:
%
% measDataFile              [string]    Path to the measurement file,
%                                       this is the file generated by
%                                       mergeRawData
% measDataStart             [num]       Start time for comparision
% measDataStop              [num]       Stop time for comparision
% pairs                     [cell]      Cell array, each row has the
%                                       elements ID, Simulation,
%                                       Measurement, Name, Scaling, Level,
%                                       see below for explanation
% plots.single              [mat]       Vector containing the pairs IDs to
%                                       be plotted as single plots
%      .combine             [cell]      Cell arrays of vectors containing
%                                       pairs IDs to be plotted as
%                                       combination
%      .errordistr          [mat]       Vector of pair IDs from which the
%                                       error distribution has to be calculated 
%      .saveas                          Cell array with file types for
%                                       image saving. See: help saveas
% errCalc.processThreshold  [mat]       Threshold value for the process
%                                       state
%        .readyThreshold    [mat]       Threshold value for the ready state
%        .source            [string]    Signal name to be taken as sources
%                                       for the given thresholds
%                                       (pairs:Simulation)
%
% The elements in the pairs cell have the following meaning:
%   ID:         Unique numerical identifier, will be sorted!
%   Simulation: Name of the logged simulation signal in the from:
%               Component.Port (e.g.: Spindle.Torque)
%   Measurment: Full name of the measured signal in the measurment file:
%               CLT#:P or CAIR:{AIR/N2}:FLOW
%   Name:       User defined name. Used for plot titles and image saving
%   Scaling:    Scaling factor for the measurment. Can be used to calculate
%               from m3/h to W or similar. Use with caution!
%   Level:      Level of component, special: 0->Linefilter, -1-> compressed
%               air
%
% The following steps are taken:
%   1) Plotting of simulation vs. measurement for each element in "pairs"
%   2) Plotting of all combined plots
%   3) Stacked area plot with all signals in pairs
%   4) Error calculation and plotting
% Besides the plots, latex output of the error calculation is provided. 
% The generated plots and result are stored in the folder "plots"

%% Configuration

% Home and measurement directory
global HOMEDIR;
global MEASDIR;

if isempty(HOMEDIR)
    fprintf('[!] HOMEDIR not set!\n');
    return 
elseif isempty(MEASDIR)
    fprintf('[!] MEASDIR not set!\n');
    return 
end

% Error limit
errLimit = 20; % [%]

%% NO CHANGES NEED FROM HERE!

%% Add path
addpath('.');

%% Preprocess

% Load configuraiton
run([HOMEDIR '/' setName '/energy/config']);

%% Path
% Creat std path

simFile = [HOMEDIR '/' setName '/simdata/simulation_output.dat'];
plotDir = [HOMEDIR '/' setName '/energy/plots/'];

%% Load measurment data
measData = importdata(measDataFile);
measData.time = measData.data(:,1)-measData.data(1,1);
measRgn = (measData.time>measDataStart & measData.time<measDataStop);
fprintf('[+] Energy measurment data loaded\n');

%% Load simulation data
if exist('thPairs','var')
    simData = loadSimFile(simFile, [pairs(:,2);thPairs(:,2)]);
else
    simData = loadSimFile(simFile, pairs(:,2));
end

%% Power sum
% Preserve space for sum
sumMeasTotal = 0;
sumSimTotal  = 0;

sumElMeasTotal = 0;
sumElSimTotal  = 0;

for i=1:size(pairs,1)
    
    measID  = find(strcmp(measData.colheaders, pairs{i,3}));
    simID   = find(strcmp(simData.colheaders, pairs{i,2}));
    
    % @TODO: Automatische Erkennung der levels
    if pairs{i,6} ~= 0
        sumMeasTotal = sumMeasTotal + measData.data(measRgn,measID)*pairs{i,5};
        sumSimTotal  = sumSimTotal  + simData.data(:,simID);
    end
    
    if pairs{i,6} == 1
        sumElMeasTotal = sumElMeasTotal + measData.data(measRgn,measID)*pairs{i,5};
        sumElSimTotal  = sumElSimTotal  + simData.data(:,simID);
    end
end


%% Single plots
fHandler = [];
fTitles  = {};

% Single plots
for i=1:length(plots.single)
    fHandler(end+1) = figure;
    
    pairID = find(plots.single(i) == cell2mat(pairs(:,1)));
    
    % Plot meas. data
    measID  = find(strcmp(measData.colheaders, pairs{pairID,3}));
    plot(measData.time(measRgn)-min(measData.time(measRgn)),measData.data(measRgn,measID)*pairs{pairID,5},':k'); hold on
    
    % Plot sim. data
    simID   = find(strcmp(simData.colheaders, pairs{pairID,2}));
    plot(simData.time, simData.data(:,simID),'k');
    
    
    legend('Measurment','Simulation');
    xlabel('time [s]')
    ylabel('Power [W]');
    title(pairs{pairID,4});
    
    axis([0 max(simData.time) 0 max(max(simData.data(:,simID))+1,mean(measData.data(measRgn,measID)*pairs{pairID,5}))*1.1]);
    
    fTitles{end+1}  = [ 'Single: ' pairs{pairID,4}];
end

%% Combined plots
colors = {'b','r','g','y','c','k'};

for i=1:size(plots.combine,1)
    leg = {};
    xMax = 0;
    sumMeas = 0;
    sumSim  = 0;
    fHandler(end+1) = figure;
    fTitles{end+1}  = [ 'Comb: ' plots.combine{i,2}];
    
    members = plots.combine{i,1};

    for j=1:length(members)
        pairID = find(members(j) == cell2mat(pairs(:,1)));

        % Plot meas. data
        measID  = find(strcmp(measData.colheaders, pairs{pairID,3}));
        plot(measData.time(measRgn)-min(measData.time(measRgn)),measData.data(measRgn,measID)*pairs{pairID,5},[':' colors{j}]); hold on

        % Plot sim. data
        simID   = find(strcmp(simData.colheaders, pairs{pairID,2}));
        plot(simData.time, simData.data(:,simID),colors{j});

        xMax = max(max(max(simData.data(:,simID)),mean(measData.data(measRgn,measID)*pairs{pairID,5}))*1.1,xMax);

        leg{end+1} = [pairs{pairID,4} ' (Measurment)'];
        leg{end+1} = [pairs{pairID,4} ' (Simulation)'];
        
        sumMeas = sumMeas + measData.data(measRgn,measID)*pairs{pairID,5};
        sumSim  = sumSim  + simData.data(:,simID);

    end
    
    plot(measData.time(measRgn)-min(measData.time(measRgn)),sumMeas,[':' colors{end}]); hold on
    plot(simData.time, sumSim,colors{end});
    
    leg{end+1} = 'Sum (Measurment)';
    leg{end+1} = 'Sum (Simulation)';

    legend(leg);
    xlabel('time [s]')
    ylabel('Power [W]');
    title(plots.combine{i,2});
    axis([0 max(simData.time) 0 max(max(sumSim),mean(sumMeas)*1.1)]);
end

%% Area Plots

simDataSerie.values  = [];
measDataSerie.values = [];

simDataSerie.time    = simData.time;
measDataSerie.time   = measData.time(measRgn)-min(measData.time(measRgn));

for i=1:size(pairs,1)
    measID  = find(strcmp(measData.colheaders, pairs{i,3}));
    simID   = find(strcmp(simData.colheaders,  pairs{i,2}));
    
    if pairs{i,6}~=0
        simDataSerie.values(end+1,:)  = simData.data(:,simID);
        measDataSerie.values(end+1,:) = measData.data(measRgn,measID)*pairs{i,5};
    end
end


% Find members of range 0 and -1
pairIDEl    = find(0 == cell2mat(pairs(:,6)));
measIDEl    = find(strcmp(measData.colheaders, pairs{pairIDEl,3}));
pairIDCair  = find(-1 == cell2mat(pairs(:,6)));
measIDCair  = find(strcmp(measData.colheaders, pairs{pairIDCair,3}));

fHandler(end+1) = figure;
fTitles{end+1}  = 'Area: Simulation';
area(simDataSerie.time, simDataSerie.values'/1000); hold on;
% Plot Total energy + compressed air
plot(measData.time(measRgn)-min(measData.time(measRgn)), ...
    measData.data(measRgn,measIDEl)  *pairs{pairIDEl,5}/1000 + ...
    measData.data(measRgn,measIDCair)*pairs{pairIDCair,5}/1000,':k');
legend(pairs(cell2mat(pairs(:,6))~=0, 4),'Location','EastOutside');
xlabel('time [s]');
ylabel('power [kW]');

fHandler(end+1) = figure;
fTitles{end+1}  = 'Area: Measurement';
area(measDataSerie.time, measDataSerie.values'/1000); hold on;
plot(measData.time(measRgn)-min(measData.time(measRgn)), ...
    measData.data(measRgn,measIDEl)  *pairs{pairIDEl,5}/1000 + ...
    measData.data(measRgn,measIDCair)*pairs{pairIDCair,5}/1000,':k');
legend(pairs(cell2mat(pairs(:,6))~=0, 4),'Location','EastOutside');
xlabel('time [s]');
ylabel('power [kW]');


%% Error calculation

if exist('errCalc','var')
    
    simID       = find(strcmp(simData.colheaders,  errCalc.source));
    triggerVals = interp1(simData.time, simData.data(:,simID), ...
        measData.time(measRgn)-min(measData.time(measRgn)), 'linear', 0);
    
    % Process rang
    processRngM = triggerVals>=errCalc.processThreshold;
    processRng  = simData.data(:,simID)>=errCalc.processThreshold;
    
    % Ready range
    readyRngM   = (triggerVals>=errCalc.readyThreshold) & ~processRngM;
    readyRng    = (simData.data(:,simID)>=errCalc.readyThreshold)  & ~processRng;
         
    % Standby range
    standbyRng    = ~( processRng  | readyRng);
    standbyRngM   = ~( processRngM | readyRngM);
    
    offRng  = ~( processRng  | readyRng | standbyRng);
    offRngM = ~( processRngM | readyRngM | standbyRngM);
    
    % Time durations
    processTime = diff(simData.time(1:2))*sum(processRng);
    readyTime   = diff(simData.time(1:2))*sum(readyRng);
    standbyTime = diff(simData.time(1:2))*sum(standbyRng);
    offTime     = diff(simData.time(1:2))*sum(offRng);
    
    measToLong = (measData.time(measRgn)-min(measData.time(measRgn)))>simData.time(end);
    processRngM(measToLong) = 0;
    readyRngM(measToLong)   = 0;
    standbyRngM(measToLong) = 0;
    offRngM(measToLong)     = 0;
    
    
    % Define evaluation ranges, total times and names
    errRng.names   = {'off', 'standby', 'ready', 'process'};
    errRng.sim{1}  = offRng;
    errRng.sim{2}  = standbyRng;
    errRng.sim{3}  = readyRng;
    errRng.sim{4}  = processRng;
    errRng.meas{1} = offRngM;
    errRng.meas{2} = standbyRngM;
    errRng.meas{3} = readyRngM;
    errRng.meas{4} = processRngM;
    errRng.duration = [ offTime, ... 
                        standbyTime, ...
                        readyTime, ...
                        processTime ];
                    
                    
        
    errRelResults = zeros(size(pairs,1)+1, length(errRng.names)+1);
    errAbsResults = zeros(size(pairs,1)+1, length(errRng.names)+1);
    
    avgPwrSim     = zeros(size(pairs,1), length(errRng.names));
    avgPwrMeas    = zeros(size(pairs,1), length(errRng.names));
    
    sumMeasAll = 0;
    sumSimAll  = 0;
    
    totalEnergyM = 0;
    totalEnergyS = 0;
  
    
    for i=1:size(pairs,1)
        
        % Find meas. data
        measID  = find(strcmp(measData.colheaders, pairs{i,3}));
        % Find sim. data
        simID   = find(strcmp(simData.colheaders, pairs{i,2}));
        
        measVals = measData.data(measRgn,measID)*pairs{i,5};
        measTime = measData.time(measRgn)-min(measData.time(measRgn));
        
       % measVals(measVals<10) = 0;
        
        % Energy consumption over time steps
        energyM = [measVals(1:end-1).*diff(measTime); 0];
        
        energyS = [interp1(simData.time, simData.data(:,simID), measTime(1:end-1), 'nearest').*diff(measTime); 0];
        
        if pairs{i,6} ~= 0
            totalEnergyM = totalEnergyM + energyM;
            totalEnergyS = totalEnergyS + energyS;
        end
        
        % Error Dirstribution
        relErr = -(energyM - energyS) ./ ...
                   energyM;
                      
        relErr(energyM == 0 & energyS==0) = 0;

        
        relErr(isnan(relErr)) = 1;
        relErr(isinf(relErr)) = 1;
        
        absErr = energyS - energyM;
              
        
        % Do error plot for each required pair
        if any(plots.errordirstr == pairs{i,1})
            
            % State specific realtive error distribution
            fHandler(end+1) = figure;
            fTitles{end+1}  = ['ErrRelDistribution: ' pairs{i,4}];

            x = 3*std(relErr(~isnan(relErr)))*[-1 1] + mean(relErr(~isnan(relErr)));
            x = linspace(x(1), x(2), 100);

            for s=1:length(errRng.names)
                [n e] = hist(relErr(errRng.meas{s} & (1~=relErr) & (abs(relErr)<2) ), x);
                n = n/(sum(n));

                if sum(n)>1.01 || sum(n)<.99 || max(n)>1
                    fprintf(['[!] Error distribution '''  pairs{i,4} ''' will be wrong\n']);
                end

                subplot(length(errRng.names), 1, s)
                bar(e*100, n*100,'hist')
                colormap('gray')

                xlabel('absolute relative error [%]');
                ylabel('distribution [%]');

                title(errRng.names{s});
            end
            
            % State specific absolute error distribution
            fHandler(end+1) = figure;
            fTitles{end+1}  = ['ErrAbsDistribution: ' pairs{i,4}];
                       
            x = 3*std(absErr(~isnan(absErr)))*[-1 1] + mean(absErr(~isnan(absErr)));
            x = linspace(x(1), x(2), 100);

            for s=1:length(errRng.names)
                [n e] = hist(absErr(errRng.meas{s}), x);
                n = n/(sum(n));

                if sum(n)>1.01 || sum(n)<.99 || max(n)>1
                    fprintf(['[!] Error distribution '''  pairs{i,4} ''' will be wrong\n']);
                end

                subplot(length(errRng.names), 1, s)
                bar(e, n*100,'hist')
                colormap('gray')

                xlabel('absolute error [W]');
                ylabel('distribution [%]');

                title(errRng.names{s});
            end
        end
            
               
        
        % State specific energy consumption
        for s=1:length(errRng.names)
            
            tmpMeas = sum(energyM(errRng.meas{s}));
            tmpSim  = sum(energyS(errRng.meas{s}));
    
            avgPwrSim(i,s)  = tmpSim  / errRng.duration(s);
            avgPwrMeas(i,s) = tmpMeas  / errRng.duration(s);
            
            errRelResults(i,s) =  (avgPwrSim(i,s)-avgPwrMeas(i,s))/avgPwrMeas(i,s);
            errAbsResults(i,s) =  avgPwrSim(i,s) - avgPwrMeas(i,s);
        end
        
         % Total energy consumptions
        sumMeas   = sum(energyM(~measToLong));
        sumSim    = sum(energyS(~measToLong));
        
        errRelResults(i,end)  =  mean(relErr(~measToLong & (1~=relErr) & (abs(relErr)<2) ));
        errAbsResults(i,end)  =  ( sumSim - sumMeas ) / sum(errRng.duration);
        
        
        % Sum over simulated and measured components
        % @TODO: Automatische Erkennung der levels
        if pairs{i,6} ~= 0
            sumMeasAll = sumMeasAll + sumMeas;
            sumSimAll  = sumSimAll  + sumSim;
        end

    end
    
    % Sum of component
    relErr = -(totalEnergyM - totalEnergyS) ./ ...
               totalEnergyM;
    relErr(totalEnergyM == 0 & totalEnergyS==0) = 0;
    relErr(isnan(relErr)) = 1;
    relErr(isinf(relErr)) = 1;
    
    for s=1:length(errRng.names)
        tmpMeas = sum( totalEnergyM(errRng.meas{s}) );
        tmpSim  = sum( totalEnergyS(errRng.meas{s}) );
        
        tmp1 = tmpSim   / errRng.duration(s);
        tmp2 = tmpMeas  / errRng.duration(s);

        errRelResults(end,s) =  (tmp1-tmp2)/tmp2;
        errAbsResults(end,s) =  tmp1-tmp2;
    end
    
    sumMeas   = sum(totalEnergyM(~measToLong));
    sumSim    = sum(totalEnergyS(~measToLong));

    errRelResults(end,end)  =  mean(relErr(~measToLong & (1~=relErr) & (abs(relErr)<2) ));
    errAbsResults(end,end)  =  ( sumSim - sumMeas ) / sum(errRng.duration);
    

    % Rel Error
    fHandler(end+1) = figure;
    a = axes('Parent',fHandler(end),'YTickLabel',[pairs(:,4)', {'Sum of components'}],'YTick',1:(size(pairs,1))+1);
    box(a,'on');
    hold(a,'on');
    grid on;
    
    barh(errRelResults*100);
    colormap gray
    legend([errRng.names, {'TOTAL'}], 'Location','Best')
    plot(-errLimit*[1,1], [0, size(pairs,1)+2],'--r', ...
          errLimit*[1,1], [0, size(pairs,1)+2],'--r');
      
    xlabel('Relative error [%]')
    
    title(['Total Power: Measured ' num2str(round(sumMeasAll/3600)/1e3) 'kWh, Simulated ' num2str(round(sumSimAll/3600)/1e3) 'kWh, over ' num2str(simData.time(end)/3600) ' hours']);
    
    fTitles{end+1}  = 'RelError: Operation States';
    
    % Abs error
    fHandler(end+1) = figure;
    a = axes('Parent',fHandler(end),'YTickLabel',[pairs(:,4)', {'Sum of components'}],'YTick',1:(size(pairs,1))+1);
    box(a,'on');
    hold(a,'on');
    grid on;
    
    barh(errAbsResults);
    colormap gray
    legend([errRng.names, {'TOTAL'}], 'Location','Best')
      
    xlabel('Absolute error [W]')
    
    title(['Total Power: Measured ' num2str(round(sumMeasAll/3600)/1e3) 'kWh, Simulated ' num2str(round(sumSimAll/3600)/1e3) 'kWh, over ' num2str(simData.time(end)/3600) ' hours']);
    
    fTitles{end+1}  = 'AbsError: Operation States';
    
   
end

%% Plot sum of energy
if exist('errCalc','var')

    fHandler(end+1) = figure;
    fTitles{end+1}  = 'Single: Sum of electrical energy';

    % Find members of range 0
    pairID = find(0 == cell2mat(pairs(:,6)));
    measID  = find(strcmp(measData.colheaders, pairs{pairID,3}));

    subplot(4,1,1:3)
    plot(measData.time(measRgn)-min(measData.time(measRgn)),measData.data(measRgn,measID)*pairs{pairID,5},':r'); hold on
    plot(measData.time(measRgn)-min(measData.time(measRgn)),sumElMeasTotal,':k')
    plot(simData.time, sumElSimTotal,'k');

    axis([0 max(simData.time) 0 max(max(sumElSimTotal)+1,mean(sumElMeasTotal))*1.1]);


    legend('Measured at line filter','Measurment','Simulation');
    xlabel('time [s]')
    ylabel('Power [W]');
    title('Sum of electrical energy');
    
    tmp=[];
    for i=1:length(errRng.sim)
        tmp(i,:) = errRng.sim{i}'*i;
    end
    tmp = sum(tmp);
    
    s = subplot(4,1,4,'YTickLabel',errRng.names, 'YTick',1:length(errRng.meas),'XTick', [],'YGrid','on');
    
    box(s,'off');
    hold(s,'all');
    
    plot(simData.time,tmp,'Parent',s,'Color',[0 0 0])
    axis([0 max(simData.time) 0 length(errRng.meas)+.5]);
   % axes('Parent',f,'YTickLabel',errRng.names,'YTick',1:length(errRng.meas),'XTick',[]);
    title(' ')

end

%% Mean power bar plot
if exist('avgPwrSim','var')
    fHandler(end+1) = figure;
    fTitles{end+1}  = 'AvgPower';
    
    a = axes('Parent',fHandler(end),'XTickLabel',errRng.names,'XTick',1:length(errRng.names));
    box(a,'on');
    hold(a,'on');
    grid on;
    
    bar((1:length(errRng.names))+0.2, avgPwrSim(abs(cell2mat(pairs(:,6)))~=0,:)'/1000,0.3,'stacked');
    bar((1:length(errRng.names))-0.2, avgPwrMeas(abs(cell2mat(pairs(:,6)))~=0,:)'/1000,0.3,'stacked');
    
    legend(pairs(cell2mat(pairs(:,6))~=0, 4),'Location','EastOutside');
    title('Average power during machine states');
    ylabel('power [kW]');
    
    m = max(max(max(avgPwrSim,avgPwrMeas)))/1000;
    axis([0 length(errRng.names)+1 0 m*1.1])
    
    text(length(errRng.names)+2, m, 'Left: Measurment')
    text(length(errRng.names)+2, m*.95, 'Right: Simulation')

end

%% Save Plots
callerPath = pwd;
cd(plotDir);

for i=1:length(fHandler);
    fprintf(['   >  ' fTitles{i} ' ... ']);
    
    file_name = regexprep(fTitles{i},'[/\s.:;,]*','_');
    
    for j=1:length(plots.saveas)
        saveas(fHandler(i), file_name, plots.saveas{j});
    end
    close(fHandler(i));
    fprintf(' done!\n');
end

%% Export for latex
fprintf(['   >  Export error table for Latex ... ']);

names = [pairs(:,4)', {'Sum of components'}];

cols = 'l';
for i=1:length(errRng.names)
    cols = [cols 'r@{.}l@{ }r'];
end

tex_out = [ '\\begin{table}\n', ...
            '\t\\centering\n', ...
            '\t\\footnotesize\n', ...
            '\t\\begin{tabular}{' cols '}\n', ...
            '\t\\toprule', ...
            '\t\tComponent'];
for i=1:length(errRng.names)
    tex_out = [ tex_out '\t& \\multicolumn{3}{c}{' upper(errRng.names{i}) '}'];
end
tex_out = [ tex_out '\\\\\n' ...
            '\t\\midrule\n' ];

for i=1:size(errAbsResults,1)
    tex_out = [ tex_out '\t\t' names{i} '\t& '];
    if 1 %i==size(errAbsResults,1) || pairs{min(i,size(errAbsResults,1)-1),6} ~= 0
        for j=1:(length(errRng.names)-1)
            if isnan(errRelResults(i,j))
                tex_out = [ tex_out '\\multicolumn{3}{c}{--}\t& ' ];
            else
                tex_out = [ tex_out strrep(strrep(sprintf('%1.1f',errRelResults(i,j)*100),'.','&'), '-', '$-$') '\\%%\t& ($\\unit[' num2str(round(errAbsResults(i,j))) ']{W}$)\t& '];
            end
        end
        j = j+1;
        if isnan(errRelResults(i,j))
            tex_out = [ tex_out '\\multicolumn{3}{c}{--}\\\\\n' ];
        else
            tex_out = [ tex_out strrep(sprintf('%1.1f',errRelResults(i,j)*100),'.','&') '\\%%\t& ($\\unit[' num2str(round(errAbsResults(i,j))) ']{W}$)\\\\\n'];
        end
    end
end
tex_out = [ tex_out  '\t\t\\bottomrule\n' ...
                     '\t\\end{tabular}\n' ...
                     '\t\\normalsize\n' ...
                     '\t\\caption[\\TODO]{\\TODO}\n' ...
                     '\\end{table}\n'];

try
    id = fopen([ 'error_' setName '.tex'], 'w');
    fprintf(id, tex_out);
    fclose(id);
catch
    error('Can''t open file');
end

fprintf(' done!\n');


cd(callerPath);
%%
end
